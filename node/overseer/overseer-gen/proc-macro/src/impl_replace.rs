// Copyright 2021 Parity Technologies (UK) Ltd.
// This file is part of Polkadot.

// Polkadot is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Polkadot is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Polkadot.  If not, see <http://www.gnu.org/licenses/>.

//! Replace a subsystem with a different implementation.

use proc_macro2::TokenStream;
use quote::quote;
use syn::{Ident, Result};

use super::*;

pub(crate) fn impl_replacable_subsystem(
	info: &OverseerInfo,
) -> Result<proc_macro2::TokenStream> {
	let msg = "Generated by #[overlord] derive proc-macro.";

	let overseer_name = &info.overseer_name;

	let error_ty = &info.error_ty;

	let field_ty = &info.builder_generic_types();
	let baggage_generic_ty = &info.baggage_generic_types();

	let baggage_name = &info.baggage_names();

	let generics = quote! {
		< Ctx, S, #( #baggage_generic_ty, )* #( #field_ty, )* >
	};

	let where_clause = quote! {
		where
			Ctx: SubsystemContext<Error = #error_ty>,
			S: ::polkadot_overseer_gen::SpawnNamed,
			#( #field_ty : Subsystem<Ctx>, )*
	};

	let mut additive = TokenStream::new();

	// generate an impl of `fn replace_#name`
	for SubSysField { name: replacable_item, ty: _replacable_item_ty, generic, .. } in info.subsystems.iter() {
		let keeper = info.subsystems.iter().filter(|&ssf| ssf.generic != *generic).map(|ssf| ssf.name.clone());

		let fn_name = Ident::new(format!("replace_{}", replacable_item).as_str(), replacable_item.span());
		// adjust the generics such that the appropriate member type is replaced

		let new = Ident::new("NEW", replacable_item.span());
		let modified_generics = &info.subsystems
			.iter()
			.map(|ssf| if ssf.generic != *generic { ssf.generic.clone() } else { new.clone() })
			.collect::<Vec<_>>();

		let modified_generics = quote! {
			< Ctx, #( #baggage_generic_ty, )* #( #modified_generics, )* >
		};

		let x: TokenStream = quote! {
			impl #generics #overseer_name #generics #where_clause {
				#[doc = #msg]
				pub fn #fn_name < #new > (self, replacement: #new) -> #overseer_name #modified_generics
				where
					#new: Subsystem<Ctx>,
				{
					#overseer_name :: #modified_generics {
						#replacable_item: replacement,
						#(
							#keeper: self. #keeper,
						)*
						#(
							#baggage_name: self. #baggage_name,
						)*
					}
				}
			}
		};
		additive.extend(x);
	}

	Ok(additive)
}
